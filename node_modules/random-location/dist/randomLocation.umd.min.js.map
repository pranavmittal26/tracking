{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///randomLocation.umd.min.js","webpack:///webpack/bootstrap 0a20f7584101335cfec3","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","DEG_TO_RAD","Math","PI","THREE_PI","TWO_PI","toRadians","deg","toDegrees","rad","randomCircumferencePoint","centerPoint","radius","sinLat","sin","latitude","cosLat","cos","bearing","random","sinBearing","cosBearing","theta","sinTheta","cosTheta","rLatitude","rLongitude","asin","longitude","atan2","randomCirclePoint","sqrt","distance","P1","P2","rP1","rP2","D","A","haversine"],"mappings":"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","file":"randomLocation.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"randomLocation\"] = factory();\n\telse\n\t\troot[\"randomLocation\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"randomLocation\"] = factory();\n\telse\n\t\troot[\"randomLocation\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar EARTH_RADIUS = 6371000; // meters\nvar DEG_TO_RAD = Math.PI / 180.0;\nvar THREE_PI = Math.PI * 3;\nvar TWO_PI = Math.PI * 2;\n\nvar toRadians = function toRadians(deg) {\n  return deg * DEG_TO_RAD;\n};\nvar toDegrees = function toDegrees(rad) {\n  return rad / DEG_TO_RAD;\n};\n\n/*\nGiven a centerPoint C and a radius R, returns a random point that is on the\ncircumference defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n\nBased on: http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n*/\nvar randomCircumferencePoint = function randomCircumferencePoint(centerPoint, radius) {\n  var sinLat = Math.sin(toRadians(centerPoint.latitude));\n  var cosLat = Math.cos(toRadians(centerPoint.latitude));\n\n  // Random bearing (direction out 360 degrees)\n  var bearing = Math.random() * TWO_PI;\n  var sinBearing = Math.sin(bearing);\n  var cosBearing = Math.cos(bearing);\n\n  // Theta is the approximated angular distance\n  var theta = radius / EARTH_RADIUS;\n  var sinTheta = Math.sin(theta);\n  var cosTheta = Math.cos(theta);\n\n  var rLatitude = void 0,\n      rLongitude = void 0;\n  rLatitude = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing);\n\n  rLongitude = toRadians(centerPoint.longitude) + Math.atan2(sinBearing * sinTheta * cosLat, cosTheta - sinLat * Math.sin(rLatitude));\n\n  // Normalize longitude L such that -PI < L < +PI\n  rLongitude = (rLongitude + THREE_PI) % TWO_PI - Math.PI;\n\n  return { latitude: toDegrees(rLatitude), longitude: toDegrees(rLongitude) };\n};\n\n/*\nGiven a centerPoint C and a radius R, returns a random point that is inside\nthe circle defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n*/\nvar randomCirclePoint = function randomCirclePoint(centerPoint, radius) {\n  // http://mathworld.wolfram.com/DiskPointPicking.html\n  return randomCircumferencePoint(centerPoint, Math.sqrt(Math.random()) * radius);\n};\n\n/*\nReturns the distance in meters between two points P1 and P2. \n\nP1 and P2 are of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nBasically it is the Haversine distance function.\nBased on: http://www.movable-type.co.uk/scripts/latlong.html\n*/\nvar distance = function distance(P1, P2) {\n  var rP1 = {\n    latitude: toRadians(P1.latitude),\n    longitude: toRadians(P1.longitude)\n  };\n  var rP2 = {\n    latitude: toRadians(P2.latitude),\n    longitude: toRadians(P2.longitude)\n  };\n\n  var D = {\n    latitude: Math.sin((rP2.latitude - rP1.latitude) / 2),\n    longitude: Math.sin((rP2.longitude - rP1.longitude) / 2)\n  };\n\n  var A = D.latitude * D.latitude + D.longitude * D.longitude * Math.cos(rP1.latitude) * Math.cos(rP2.latitude);\n\n  var C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1 - A));\n\n  return EARTH_RADIUS * C;\n};\n\nvar haversine = distance;\n\nmodule.exports = {\n  distance: distance,\n  haversine: haversine,\n  randomCircumferencePoint: randomCircumferencePoint,\n  randomCirclePoint: randomCirclePoint\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// randomLocation.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0a20f7584101335cfec3","const EARTH_RADIUS = 6371000 // meters\nconst DEG_TO_RAD = Math.PI / 180.0\nconst THREE_PI = Math.PI * 3\nconst TWO_PI = Math.PI * 2\n\nconst toRadians = deg => deg * DEG_TO_RAD\nconst toDegrees = rad => rad / DEG_TO_RAD\n\n/*\nGiven a centerPoint C and a radius R, returns a random point that is on the\ncircumference defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n\nBased on: http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n*/\nconst randomCircumferencePoint = (centerPoint, radius) => {\n  const sinLat = Math.sin(toRadians(centerPoint.latitude))\n  const cosLat = Math.cos(toRadians(centerPoint.latitude))\n\n  // Random bearing (direction out 360 degrees)\n  const bearing = Math.random() * TWO_PI\n  const sinBearing = Math.sin(bearing)\n  const cosBearing = Math.cos(bearing)\n\n  // Theta is the approximated angular distance\n  const theta = radius / EARTH_RADIUS\n  const sinTheta = Math.sin(theta)\n  const cosTheta = Math.cos(theta)\n\n  let rLatitude, rLongitude\n  rLatitude = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing)\n\n  rLongitude =\n    toRadians(centerPoint.longitude) +\n    Math.atan2(\n      sinBearing * sinTheta * cosLat,\n      cosTheta - sinLat * Math.sin(rLatitude)\n    )\n\n  // Normalize longitude L such that -PI < L < +PI\n  rLongitude = (rLongitude + THREE_PI) % TWO_PI - Math.PI\n\n  return { latitude: toDegrees(rLatitude), longitude: toDegrees(rLongitude) }\n}\n\n/*\nGiven a centerPoint C and a radius R, returns a random point that is inside\nthe circle defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n*/\nconst randomCirclePoint = (centerPoint, radius) => {\n  // http://mathworld.wolfram.com/DiskPointPicking.html\n  return randomCircumferencePoint(\n    centerPoint,\n    Math.sqrt(Math.random()) * radius\n  )\n}\n\n/*\nReturns the distance in meters between two points P1 and P2. \n\nP1 and P2 are of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nBasically it is the Haversine distance function.\nBased on: http://www.movable-type.co.uk/scripts/latlong.html\n*/\nconst distance = (P1, P2) => {\n  const rP1 = {\n    latitude: toRadians(P1.latitude),\n    longitude: toRadians(P1.longitude),\n  }\n  const rP2 = {\n    latitude: toRadians(P2.latitude),\n    longitude: toRadians(P2.longitude),\n  }\n\n  const D = {\n    latitude: Math.sin((rP2.latitude - rP1.latitude) / 2),\n    longitude: Math.sin((rP2.longitude - rP1.longitude) / 2),\n  }\n\n  const A =\n    D.latitude * D.latitude +\n    D.longitude * D.longitude * Math.cos(rP1.latitude) * Math.cos(rP2.latitude)\n\n  const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1 - A))\n\n  return EARTH_RADIUS * C\n}\n\nconst haversine = distance\n\nmodule.exports = {\n  distance,\n  haversine,\n  randomCircumferencePoint,\n  randomCirclePoint,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}