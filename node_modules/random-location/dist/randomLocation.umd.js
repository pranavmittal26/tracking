(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["randomLocation"] = factory();
	else
		root["randomLocation"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EARTH_RADIUS = 6371000; // meters
var DEG_TO_RAD = Math.PI / 180.0;
var THREE_PI = Math.PI * 3;
var TWO_PI = Math.PI * 2;

var toRadians = function toRadians(deg) {
  return deg * DEG_TO_RAD;
};
var toDegrees = function toDegrees(rad) {
  return rad / DEG_TO_RAD;
};

/*
Given a centerPoint C and a radius R, returns a random point that is on the
circumference defined by C and R.

centerPoint C is of type { latitude: A, longitude: B }
Where -90 <= A <= 90 and -180 <= B <= 180.

radius R is in meters.

Based on: http://www.movable-type.co.uk/scripts/latlong.html#destPoint
*/
var randomCircumferencePoint = function randomCircumferencePoint(centerPoint, radius) {
  var sinLat = Math.sin(toRadians(centerPoint.latitude));
  var cosLat = Math.cos(toRadians(centerPoint.latitude));

  // Random bearing (direction out 360 degrees)
  var bearing = Math.random() * TWO_PI;
  var sinBearing = Math.sin(bearing);
  var cosBearing = Math.cos(bearing);

  // Theta is the approximated angular distance
  var theta = radius / EARTH_RADIUS;
  var sinTheta = Math.sin(theta);
  var cosTheta = Math.cos(theta);

  var rLatitude = void 0,
      rLongitude = void 0;
  rLatitude = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing);

  rLongitude = toRadians(centerPoint.longitude) + Math.atan2(sinBearing * sinTheta * cosLat, cosTheta - sinLat * Math.sin(rLatitude));

  // Normalize longitude L such that -PI < L < +PI
  rLongitude = (rLongitude + THREE_PI) % TWO_PI - Math.PI;

  return { latitude: toDegrees(rLatitude), longitude: toDegrees(rLongitude) };
};

/*
Given a centerPoint C and a radius R, returns a random point that is inside
the circle defined by C and R.

centerPoint C is of type { latitude: A, longitude: B }
Where -90 <= A <= 90 and -180 <= B <= 180.

radius R is in meters.
*/
var randomCirclePoint = function randomCirclePoint(centerPoint, radius) {
  // http://mathworld.wolfram.com/DiskPointPicking.html
  return randomCircumferencePoint(centerPoint, Math.sqrt(Math.random()) * radius);
};

/*
Returns the distance in meters between two points P1 and P2. 

P1 and P2 are of type { latitude: A, longitude: B }
Where -90 <= A <= 90 and -180 <= B <= 180.

Basically it is the Haversine distance function.
Based on: http://www.movable-type.co.uk/scripts/latlong.html
*/
var distance = function distance(P1, P2) {
  var rP1 = {
    latitude: toRadians(P1.latitude),
    longitude: toRadians(P1.longitude)
  };
  var rP2 = {
    latitude: toRadians(P2.latitude),
    longitude: toRadians(P2.longitude)
  };

  var D = {
    latitude: Math.sin((rP2.latitude - rP1.latitude) / 2),
    longitude: Math.sin((rP2.longitude - rP1.longitude) / 2)
  };

  var A = D.latitude * D.latitude + D.longitude * D.longitude * Math.cos(rP1.latitude) * Math.cos(rP2.latitude);

  var C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1 - A));

  return EARTH_RADIUS * C;
};

var haversine = distance;

module.exports = {
  distance: distance,
  haversine: haversine,
  randomCircumferencePoint: randomCircumferencePoint,
  randomCirclePoint: randomCirclePoint
};

/***/ })
/******/ ]);
});
//# sourceMappingURL=randomLocation.umd.js.map